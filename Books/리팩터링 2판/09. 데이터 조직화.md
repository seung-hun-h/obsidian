### 1. 변수 쪼개기
#### 배경
- 변수에 값을 여러번 대입할 수 밖에 없는 경우
	- 루프 변수(`for (int i=0;i<10;i++`)
	- 수집 변수(`for (~) {result = result + 1})
		- 메서드가 동작하는 중간 중간 값을 저장하는 경우
- 그 외 변수는 값을 단 한 번만 대입해야 한다
- 변수의 역할의 두 가지 이상이라면 한 가지 역할만 할 수 있도록 쪼개야 한다
#### 절차
1. 변수를 선언한 곳과 값을 처음 대입하는 곳에서 변수 이름을 바꾼다
2. 가능하면 이때 불면으로 선언한다
3. 이 변수에 두 번째로 값을 대입하는 곳 앞까지의 모든 참조를 새로운 변수 이름으로 바꾼다
4. 두 번째 대입 시 변수를 원래 이름으로 다시 선언한다
5. 테스트한다
6. 반복한다

### 2. 필드 이름 바꾸기
#### 배경
- 데이터 구조는 프로그램을 이해하는데 큰 도움을 준다
- 처음부터 완벽하게 데이터를 이해할 수는 없다. 도메인에 대한 깊어지는 이해를 프로그램에 반영해야 한다
	- 필드 이름을 바꾸는 것은 데이터에 대한 높아진 이해를 반영하는 것이다

#### 절차
1. 레코드의 유효 범위가 제한적인 경우, 필드에 접근하는 모든 코드를 수정한 후 테스트한다.
2. 레코드의 유효 범위가 넓은 경우, 일단 레코드를 캡슐화 한다
3. 캡슐화된 객체의 private  필드명을 변경하고 그에 맞게 내부 메서드를 수정한다
4. 테스트한다
5. 생성자의 매개변수 중 필드와 이름이 겹치는게 있다면 함수 선언 바꾸기로 변경한다
6. 접근자들의 이름도 변경해준다

> [!note]
> 캡슐화 이후 필드 이름을 바꾸게 되면 필드 접근자 메서드도 바꿔야한다.
> 이렇게 되면 필드, 생성자, 쓰기 접근자, 읽기 접근자 총 네 군데를 변경해야한다.
> 변경 지점이 많게 되므로 회의적일 수 있지만, 이렇게되면 작은 단계로 나누어 필드 이름을 변경할 수 있어 실수할 여지를 줄일 수 있다

### 3. 파생 변수를 질의 함수로 바꾸기
#### 배경
- 가변 데이터는 서로 다른 두 코드를 이상한 방식으로 결합 할 수 있는데, 이를 **파생 변수**라 한다
- 가변 데이터는 유효 범위를 최대한 좁혀야 한다
	- 값을 쉽게 계산할 수 있는 변수는 모두 제거하고 함수로 만들 수 있다
- 피연산자의 데이터가 불변이라면 계산 결과도 일정하므로 불변으로 만들 수 있다. 
	- 따라서 **변형 연산(transformation operation)** 은 계산 코드로 대체할 수 있더라도 그대로 두는 것이 좋을 수 있다
- 변형 연산
	- 데이터 구조를 감싸며 그 데이터에 기초하여 계산한 결과를 속성으로 제공하는 객체
		- 소스 데이터가 가변
		- 파생 데이터 구조의 수명을 관리해야 하는 상황
	- 데이터 구조를 받아 다른 데이터 구조로 변환해 반환하는 함수
#### 절차
1. 변수 값이 갱신되는 지점을 모두 찾는다. 필요하면 [[#1. 변수 쪼개기|변수 쪼개기]]를 활용한다
2. 해당 변수의 값을 계산해주는 함수를 만든다
3. 해당 변수가 사용되는 모든 곳에서 어셔선을 추가하여 함수의 계산 결과가 변수의 값과 같은지 확인한다
4. 테스트한다
5. 변수를 읽는 코드를 모두 함수 호출로 대체한다
6. 테스트한다
7. 변수를 선언하고 갱신하는 코드를 [[08. 기능 이동#9. 죽은 코드 제거하기|죽은 코드 제거하기]]로 없앤다

### 4. 참조를 값으로 바꾸기
#### 배경
- 객체를 다른 객체에 중첩하면 내부 객체를 참조 혹은 값으로 취급할 수 있다
- 참조로 다루는 경우, 객체의 내부 속성만 변경한다
- 값으로 다루는 경우, 새로운 속성을 담은 객체로 기존의 객체를 대체한다
- 필드를 값으로만 다룬다면 내부 객체 클래스를 수정하여 [[값 객체]]로 만들 수 있다
	- [[값 객체]]는 서로 간의 참조를 관리하지 않아도 돼서 분산 시스템이나 동시성 시스템에 유용하다
- 특정 객체를 여러 곳에서 사용하고자 하면 이 리팩터링은 적절하지 않다
#### 절차
1. 후보 클래스가 불변인지, 혹은 불변이 될 수 있는지 확인한다
2. 각각의 세터를 하나씩 제거한다
3. 이 값 객체의 필드들을 사용하는 동치성 메서드를 만든다

### 5. 값을 참조로 바꾸기
#### 배경
- 중첩 구조의 객체에서 내부 객체를 값으로 다룰 때 크게 문제가 되는 상황은 그 값을 갱신해야할 때이다
	- 값을 갱신할 때 모든 복제본을 찾아서 빠짐없이 변경해주어야 한다
- 복제된 데이터를 모두 갱신해야하는 상황이라면 참조로 변경해주는 편이 좋다
- 값을 참조로 바꾸면 엔티티 하나당 객체도 단 하나만 존재하게 된다
	- 이때 클라이언트의 접근을 관리하는 저장소가 필요해진다
	- 엔티티를 표현하는 객체를 단 하나만 만들고, 객체가 필요한 곳에서는 모두 이 저장소로부터 얻어쓰는 방식이된다
#### 절차
1. 같은 부류에 속하는 객체들을 보관할 저장소를 만든다
   - 간단한 상황에서는 [[저장소 객체]]를 사용하기도 한다
2. 생성자에서 이 부류의 객체들 중 특정 객체를 정확히 찾아내는 방법이 있는지 확인한다
3. 호스트 객체의 생성자를 수정하여 필요한 객체를 이 저장소에서 찾도록한다. 수정할 떄마다 테스트한다

### 6. 매직 리터럴 바꾸기

#### 배경
- 매직 리터럴이란 소스 코드에 등장하는 일반적인 리터럴 값을 말한다
- 매직 리터럴을 사용하기 보다는 코드 자체가 뜻을 분명하게 드러내는게 좋다
- 매직 리터럴 대신 상수를 정의하고 상수를 사용하는편이 좋다
- 상수가 특별한 비교 로직에 주로 사용된다면 함수로 추출해서 사용하는 것이 좋다
- 의미 없이 상수를 사용하는 것은 지양해야 한다
	- `int ONE = 1`은 별 의미가 없다
#### 절차
1. 상수를 선언하고 매직 리터럴을 대입한다
2. 해당 리터럴이 사용되는 곳을 모두 찾는다
3. 찾은 곳 각각에서 리터럴이 새 상수와 똑같은 의미로 쓰였는지 확인하여, 같은 의미라면 상수로 대체한 후 테스트한다
