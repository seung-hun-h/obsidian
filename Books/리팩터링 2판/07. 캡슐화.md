### 1. 레코드 캡슐화하기
#### 배경
- 레코드는 연관있는 데이터를 묶을 수 있는 장점이있다
- 레코드는 계산해서 얻을 수 있는 값과 그렇지 않은 값을 명확히 구분해서 저장해야 한다는 점이 번거롭다
- 객체를 사용하면 사용자는 무엇이 저장된 값이고 무엇이 계산된 값인지 알 필요가 없다
- 가변 데이터일 때는 객체를 사용, 불변 데이터인 경우 저장할 데이터와 계산할 데이터를 모두 구한 후 필드에 저장한다

#### 절차
1. 레코드를 담은 변수를 캡슐화 한다
2. 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체한다. 이 클래스에 원본 레코드를 반환하는 접근자도 정의하고, 변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정한다
3. 테스트한다
4. 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수를 새로 만든다
5. 레코드를 반환하는 예전 함수를 사용하는 코드를 ‘4’에서 만든 새 함수를 사용하도록 바꾼다. 필드에 접근할 때는 객체의 접근자를 사용한다. 접근자가 없다면 추가한다. 한 부분을 바꿀 때 마다 테스트한다.
	- 중첩된 구조처럼 복잡한 데이터라면 클라이언트를 유심히 살펴본다. 클라이언트가 데이터를 읽기만 한다면 데이터의 복제본이나 읽기전용 프락시를 반환할 지 고려해보자
6. 클래스에서 원본 데이터를 반환하는 접근자와 원본 레코드를 반환하는 함수들을 제거한다
7. 테스트한다
8. 레코드의 필드도 데이터 구조인 중첩 구조라면 레코드 캡슐화하기와 컬렉션 캡슐화하기를 재귀적으로 적용한다

### 2. 컬렉션 캡슐화하기
#### 배경
- 클래스의 게터가 컬렉션 자체를 반환하면 외부에서 컬렉션을 변경할 수 있다
- 내부 컬렉션을 수정하지 못하게 하는 방법
	- **절대로 컬렉션 값을 반환하지 못하게 한다.**
		- 컬렉션에 접근하기 위해서는 클래스에서 제공하는 전용 메서드를 사용한다. 
		- 부가적인 코드가 늘어나는 단점을 가지고 있다
	- **컬렉션을 읽기 전용으로 제공한다**
	- **컬렉션 게터를 제공하되 내부 컬렉션의 복제본을 반환한다**
- 중요한 것은 코드 베이스에 일관성을 주는 것이다. 하나를 선택해서 사용하도록 한다

#### 절차
1. 컬렉션을 캡슐화 하지 않았다면 캡슐화한다
2. 컬렉션에 원소를 추가/제거하는 함수를 추가한다
	- 컬렉션 자체를 통째로 바꾸는 세터는 제거한다.
	- 세터를 제거할 수 없을 때는 인수로 받은 컬렉션의 복제본을 저장하도록 한다
	- 제거 메서드에서는 컬렉션에 존재하지 않는 원소를 제거하려 할 때 대응방식을 잘 정해야한다
3. 정적 검사를 수행한다
4. 컬렉션을 참조하는 부분을 모두 찾는다. 컬렉션의 변경자를 호출하는 코드가 모두 앞에서 추가한 추가/제거 함수를 사용하도록 한다. 
5. 컬렉션 게터를 수정해서 원본 내용을 수정할 수 없는 읽기전용 프락시나 복제본을 반환하도록 한다
6. 테스트한다
### 3. 기본형을 객체로 바꾸기
#### 배경
- 단순한 출력 이상의 기능이 필요해지는 순간 데이터를 표현하는 전용 클래스를 정의하는 편이 좋다

#### 절차
1. 변수를 캡슐화 하지 않았다면 캡슐화 한다
2. 단순한 [[값 객체|값 클래스]]를 만든다. 생성자는 기존 값을 인수로 받아서 저장하고, 이 값을 반환하는 게터를 추가한다
3. 정적 검사를 수행한다
4. [[값 객체|값 클래스]]의 인스턴스를 새로 만들어서 필드에 저장하도록 세터를 수정한다. 이미 있다면 필드의 타입을 적절히 변경한다
5. 새로 만든 클래스의 게터를 호출한 결과를 반환하도록 게터를 수정한다
6. 테스트한다
7. 함수 이름을 바꾸면 원본 접근자의 동작을 더 잘 드러낼 수 있는지 검토한다

### 4. 임시 변수를 질의 함수로 바꾸기
#### 배경
- 임시 변수 대신 질의 함수를 사용할 때가 더 나은 경우가 있다
- 긴 함수의 한 부분을 별도 함수로 추출할 때 먼저 변수들을 각각의 함수로 만들면 일이 수월해진다
	- 추출한 함수에 변수를 일일히 전달할 필요가 없어진다
	- 추출한 함수와 원래 함수의 경계가 분명해진다
	- 부자연스러운 의존 관계나 부수효과를 찾고 제거하는데 도움이 된다
- 비슷한 계산을 수행하는 다른 함수에서도 사용할 수 있어 중복이 사라진다
- 질의 함수는 컨텍스트를 공유하는 클래스 내부에서 가장 효과가 좋다
- 스냅숏 용도로 쓰이는 임시 변수는 질의 함수로 리팩터링 하지 않는 것이 좋다
	- 변수에 값을 한 번 대입한 뒤 복잡한 코드 덩어리에 여러 차례 대입하는 경우 모두 질의 함수로 추출해야 한다
	- **변수는 값을 한 번만 계산하고 그 뒤로는 읽기만 해야 한다**

#### 절차
1. 변수가 사용되기 전 값이 확실히 결정되는지, 변수를 사용할 때마다 계산 로직이 매번 다른 결과를 내지 않는지 확인한다
2. 읽기전용으로 만들 수 있는 변수는 읽기 전용으로 만든다
3. 테스트한다
4. 변수 대입문을 함수로 추출한다
	- 변수와 함수가 같은 이름을 가질 수 없다면 함수 이름을 임시로 짓는다
	- 추출한 함수가 부수효과를 일으키지 않는지 확인한다
	- 부수효과가 있다면 질의 함수와 변경 함수분리하기로 대처한다ㄷ
5. 테스트한다
6. 변수 인라인하기로 임시 변수를 제거한다

### 5. 클래스 추출하기
#### 배경
- 메서드와 데이터가 너무 많은 클래스는 이해하기 쉽지 않아서 적절히 분리하는 편이 좋다
- 클래스 추출 신호
	- 일부 데이터와 메서드를 따로 묶을 수 있는 경우
	- 변경되는 일이 많거나 서로 의존하는 데이터
	- 특정 데이터나 메서드를 일부 제거해도 다른 필드나 메서드에 문제가 발생하지 않는 경우
	- 작은 기능만을 위해 서브 클래스를 만드는 경우
	- 확장할 기능에 따라서 서브 클래스를 만드는 방식이 달라지는 경우

#### 절차
1. 클리스의 역할을 분리할 방법을 정한다
2. 분리될 역할을 담당할 클래스를 새로 만든다
3. 원래 클래스의 생성자에서 새로운 클래스의 인스턴스를 생성하여 필드에 저장해둔다
4. 분리된 역할에 필요한 필드들을 새 클래스로 옮긴다. 하나씩 옮길 때마다 테스트한다
5. 메서드들도 새 클래스로 옮긴다. 이때 다른 메서드를 호출하는 것보다 호출 당하는 일이 많은 저수준 메서드부터 옮긴다
6. 양쪽 클래스의 인터페이스를 살펴보면서 불필요한 메서드를 제거하고 이름도 환경에 맞게 변경한다
7. 새 클래스를 외부로 노출할 지 결정한다. 노출하려거든 새 클래스에 [[참조를 값으로 바꾸기]]를 적용할 수 있을지 고민해본다
### 6. 클래스 인라인하기
#### 배경
- 역할을 옮기는 리팩터링을 한 후 특정 클래스에 남는 역할이 거의 없는 경우
- 두 클래스의 기능을 지금과 다르게 배분하고 싶은 경우
	- 하나로 합친다음 새로운 클래스를 추출하는게 나을 수 있다

#### 절차
1. 소스 클래스의 각 public 메서드에 대응하는 메서드듥을 타깃 클래스에 생성한다. 이 메서드들은 단순히 작업을 소스 클래스로 위임해야 한다
2. 소스 클래스의 메서드를 사용하는 코드를 모두 타깃 클래스의 위임 메서드를 사용하도록 바꾼다. 하나씩 바꿀 때마다 테스트한다
3. 소스 클래스의 메서드와 필드를 모두 타깃 클래스로 옮긴다. 하나씩 옮길 때마다 테스트한다
4. 소스 클래스를 삭제하고 조의를 표한다

### 7. 위임 숨기기
#### 배경
- 캡슐화는 모듈들이 시스템에 대해 알아야 하는 내용을 줄여 준다
- 변경이 있을 때 캡슐화가 잘되어 있으면 고려해야 할 모듈 수가 적어진다
- 서버 객체의 필드가 가리키는 객체의 메서드를 호출하기 위해 클라이언트가 위임 객체를 직접 알아야 한다. 서버 자체에 위임 메서드를 만들면 클라이언트는 객체에 대해 의존하지 않아도 된다

#### 절차
1. 위임 객체의 각 메서드에 해당하는 위임 메서드를 서버에 생성한다
2. 클라이언트가 위임 객체 대신 서버를 호출하도록 수정한다. 하나씩 바꿀 때마다 테스트한다
3. 모두 수정했다면, 서버로부터 위임 객체를 얻는 접근자를 제거한다
4. 테스트한다

### 8. 중개자 제거하기
#### 배경
- [[#7. 위임 숨기기|위임 숨기기]]를 적용하면 클라이언트가 위임 객체의 또 다른 기능을 사용할 때마다 서버에 위임 메서드를 추가해야 한다
- 과도한 [[#7. 위임 숨기기|위임 숨기기]]는 서버 클래스를 단순한 [중개자](https://luzkan.github.io/smells/middle-man)로 전락하게 만든다
- 서버 클래스가 중개자로 전락했다고 판단되면, 중개자를 제거하고 객체를 직접 호출하는 편이 나을 수 있다
#### 절차
1. 위임 객체를 얻는 게터를 만든다
2. 위임 메서드를 호출하는 클라이언트가 모두 이 게터를 거치도록 수정한다. 하나씩 바꿀때 마다 테스트한다
3. 모두 수정헀다면 위임 메서드를 삭제한다

### 9. 알고리즘 교체하기
#### 배경
- 알고리즘 전체를 걷어내고 훨씬 간결한 알고리즘으로 바꿔야할 때가 있다
	- 문제를 확실히 이해하고 쉽게 해결하는 방법을 찾았을 때
	- 직접 작성한 코드와 똑같은 기능을하는 라이브러리를 발견했을 때
- 리팩터링을 진행하기전 **함수를 충분히 잘게 나눴는지** 확인해야 한다
#### 절차
1. 교체할 코드를 함수 하나에 모은다
2. 이 함수만을 이용해 동작을 검증하는 테스트를 마련한다
3. 대체할 알고리즘을 준비한다
4. 정적 검사르 수행한다
5. 기존 알고리즘과 새 알고리즘의 결과를 비교하는 테스트를 수행한다. 결과가 같으면 끝난다. 그렇지 않다면 계속 테스트하며 수정한다
