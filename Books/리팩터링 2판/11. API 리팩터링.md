### 1. 질의 함수와 변경 함수 분리하기
#### 배경
- 외부에서 관찰할 수 있는 겉보기 부수화가가 전혀 없이 값을 반환 해주는 함수를 추구해야 한다
- 겉보기 부수효과가 있는 함수와 없는 함수는 명확히 구분해주는 것이 좋다
	- 이를 위한 방법으로 [[명령-질의 분리 원칙]]이라는 것이 있다
	- 맹목적으로 100% 지킬 필요는 없다
- 값을 반환하면서도 부수효과가 있는 함수를 발견하면 리팩토링 하라

#### 절차
1. 대상 함수를 복제하고 질의 목적에 충실한 이름을 짓는다
2. 새 질의 함수에서 부수효과를 모두 제거한다
3. 정적 검사를 수행한다
4. 원래 함수를 호출하는 곳을 모두 찾는다. 반환 값을 사용하면 질의 함수를 호출하도록 바꾸고, 원래 함수를 호출하는 코드를 아래 줄에 새로 추가한다. 하나 수정할 때마다 테스트한다
5. 원래 함수에서 질의 관련 코드를 제거한다
6. 테스트한다

### 2. 함수 매개변수화 하기
#### 배경
- 두 함수의 로직이 아주 비슷하고 단지 리터럴 값만 다르다면, 다른 값만 매개변수로 받아 함수 하나로 처리할 수 있다

#### 절차
1. 비슷한 함수 중 하나를 선택한다
2. [[06. 기본적인 리팩터링#5. 함수 선언 바꾸기|함수 선언 바꾸기]]로 리터럴들을 매개변수로 추가한다
3. 이 함수를 호출하는 곳 모두에 적절한 리터럴 값을 추가한다
4. 테스트한다
5. 매개변수로 받은 값을 사용하도록 함수 본문을 수정한다. 하나 수정할 때마다 테스트한다
6. 비슷한 다른 함수를 호출하는 코드를 찾아 매개변수화된 함수를 호출하도록 하나씩 수정한다. 하나씩 수정할 때마다 테스트한다

### 3. 플래그 인수 제거하기
#### 배경
- 플래그 인수란 호출되는 함수가 실행할 로직을 호출하는 쪽에서 선택하기 위해 전달하는 인수다
- 플래그 인수
	-  문자열, 불리언, 열거형일 수도 있다
	- 프로그램에서 사용되는 데이터가 아닌 리터럴이어야 한다
		- `doSomething(value, someType)` (x), `doSomething(value, SomeType.ACT)`(o)
	- 제어 흐름을 결정해야 한다
#### 절차
1. 매개변수로 주어질 수 있는 값 각각에 대응하는 명시적인 함수들을 생성한다
   - 주가 되는 함수에 깔끔한 분배 조건문이 포함된 경우 [[10. 조건부 로직 간소화#1. 조건문 분해하기|조건문 분해하기]]로 명시적인 함수를 생성한다
   - 그렇지 않은 경우 래핑 함수 형태로 만든다
```js
function rushDeliveryDate(anOrder) {return deliveryDate(anOrder, true);}
function regularDeliveryDate(anOrder) {return deliveryDate(anOrder, false);}
```
2. 원래 함수를 호출하는 코드들을 모두 찾아서 각 리터럴 값에 대응되는 명시적 함수를 호출하도록 수정한다

### 4. 객체 통째로 넘기기
#### 배경
- 레코드를 통쨰로 함수에 넘기면 변화에 대응하기 쉽다
	- 다양한 데이터를 사용하도록 변경되어도 매개변수 목록이 변하지 않는다
	- 매개변수 목록이 짧아져 함수를 이해하기 쉬워진다
	- 로직의 중복이 사라진다
		- 레코드의 일부 데이터를 동일하게 받는 함수는 로직의 중복이 생길 수 있다
- 함수가 레코드에 의존하지 않길 바라는 경우 이 리팩터링을 실행하지 않는다
	- 서로 다른 모듈에 있는 로직이라면 더 그렇다
- 레코드에서 **값 몇개를 얻어 그 값들만으로 동작을 수행하는 로직**이 있다면 그 로직은 해당 객체 안으로 집어 넣어야하는 악취일 수 있다
	- [[06. 기본적인 리팩터링#8. 매개변수 객체 만들기|매개변수 객체 만들기]] 후 이 리팩터링을 적용하곤 한다
- 한 객체가 제공하는 기능 중 항상 똑같은 일부만을 사용하는 코드가 많다면, 그 기능만 따로 묶어서 [[07. 캡슐화#5. 클래스 추출하기|클래스로 추출]]하라는 신호일 수 있다
#### 절차
1. 매개변수들을 원하는 형태로 받는 빈 함수를 만든다
2. 새 함수의 본문에서는 원래 함수를 호출한다. 새 매개변수와 원래 함수의 매개변수를 매핑한다
3. 정적 검사를 수행한다
4. 모든 호출자가 새 함수를 사용하게 한다. 하나씩 수정하며 테스트한다
5. 호출자를 모두 수정했다면 원래 함수를 인라인한다
6. 새 함수의 이름을 적절히 수정하고 모든 호출자에 반영한다
### 5. 매개변수를 질의 함수로 바꾸기
#### 배경
- 매개변수 목록은 함수의 변동 요인을 모아 놓은곳
- 피호출 함수가 스스로 '쉽게' 결정할 수 있는 값을 매개변수로 전달하는 것도 일종의 중복이다
- 피호출 함수가 매개변수를 결정할 수 있는 주체라면 중복을 제거하자
- 피호출 함수가 매개변수를 결정하지 못하는 상황
	- 매개변수를 제거할 경우 원치 않는 의존성이 생기는 경우
- 다른 매개변수에서 얻을 수 있는 값을 별도로 전달하는 것은 아무 의미가 없다
- 이 리팩터링을 수행하기 위해서는 피호출 함수가 참조 투명해야 한다
	- 참조 투명하다는 것은 '함수에 똑같은 값을 전달하면 항상 똑같이 동작해야 한다'는 것이다
#### 절차
1. 필요하다면 대상 매개변수의 값을 계산하는 코드를 별도의 함수로 추출한다
2. 함수 본문에서 대상 매개변수로의 참조를 모두 찾아서 그 매개변수의 값을 만들어주는 표현식을 참조하도록 바꾼다
3. [[06. 기본적인 리팩터링#5. 함수 선언 바꾸기|함수 선언 바꾸기]]로 대상 매개변수를 없앤다

### 6. 질의 함수를 매개변수로 바꾸기
#### 배경
- 코드를 읽다보면 함수 안에 두기 거북한 참조를 보는 경우가 있다
	- 전역 변수 참조
	- 제거하기를 원하는 원소 참조
- 참조를 매개변수로 바꾸면 문제를 해결할 수 있다
- '참조 투명한' 함수가 다루기 쉽다
	- 가변적인 원소를 다루는 로직은 바깥에 위치시키고 순수 함수는 안쪽에 위치 시키는 편이 좋다
- 참조 투명하지 않은 원소에 접근하는 함수는 해당 원소를 매개변수로 변경해 순수 함수로 만들 수도 있다

#### 절차
1. [[06. 기본적인 리팩터링#3. 변수 추출하기|변수 추출하기]]로 질의 코드를 함수 본문의 나머지 코드와 분리한다
2. 함수 본문 중 해당 질의를 호출하지 않는 코드를 별도의 [[06. 기본적인 리팩터링#1. 함수 추출하기|함수로 추출]]한다
3. 방금 만든 [[06. 기본적인 리팩터링#4. 변수 인라인하기|변수를 인라인]]하여 제거한다
4. 원래 [[06. 기본적인 리팩터링#2. 함수 인라인하기|함수도 인라인]]한다
5. 새 함수의 이름을 원래 함수의 이름으로 고쳐준다

### 7. 세터 제거하기
#### 배경
- 세터 메서드가 있다는 것은 필드가 변경될 수 있다는 것이다
- 객체 생성후 필드가 변경되길 바라지 않는 다면 세터를 제거하자
	- 변경되지 않는 필드라는 의도가 잘드러난다
- 이 리팩터링이 필요한 경우
	- 무조건 접근자 메서드를 통헤 필드에 접근하려 할 떄
		- 생성자 내부에서도 세터를 사용하는 경우가 있는데, 이것 보다는 세터를 제거하는 편이 낫다
	- 클라이언트에서 생성 스크립트를 사용해 객체를 생성할 때
		- 생성자 호출 후 일련의 세터를 호출하여 객체를 완성하는 코드
		- 세터를 제거하여 변경되지 않는다는 의도를 더 명백히 하자
#### 절차
1. 생성자에 설정해야 할 값을 추가한다. 생성자 안에서 적절한 세터를 호출한다
2. 생성자 밖에서 세터를 호출하는 곳을 찾아 제거하고, 새로운 생성자를 사용하도록 한다. 수정마다 테스트한다
3. 세터 [[06. 기본적인 리팩터링#2. 함수 인라인하기|메서드를 인라인]]한다. 가능하다면 필드를 불변으로 만든다
4. 테스트한다

### 8. 생성자를 팩터리 함수로 바꾸기
#### 배경
- 생성자는 객체를 초기화하는 특별한 용도의 함수다
- 생성자의 제약(자바)
	- 생성자를 정의한 클래스의 인스턴스만 반환해야 한다.
		- 서브 클래스나 프락시를 반환할 수 없다
	- 생성자의 이름이 고정되어 있다
	- 생성자를 호출하기 위해서는 특별한 연산자(`new`)를 사용해야 한다. 일반 함수가 오길 기대하는 자리에서 사용할 수 없다
- 팩터리 함수는 생성자의 제약을 해소할 수 있다
#### 절차
1. 팩터리 함수를 만든다. 팩터리 함수의 본문에는 원래 생성자를 호출한다
2. 생성자를 호출하던 코드를 팩토리 함수 호출 코드로 바꾼다
3. 하나씩 수정할 때마다 테스트한다
4. 생성자의 가시범위가 최소가 되도록 제한한다

### 9. 함수를 명령으로 바꾸기
#### 배경
- 함수를 그 함수만을 위한 객체 안으로 캡슐화하면 더 유용한 경우가 있다
	- 이러한 객체를 **명령**이라 한다
- 명령은 평범한 함수 메커니즘보다 더 유연하기 함수르 제어할 수 있다
	- 되돌리기(Undo)와 같은 보조 연산 제공
	- 수명주기를 더 정밀하게 제어하는데 필요한 매개변수를 만들어주는 메서드 제공
	- 상속과 훅으로 사용자 맞춤형으로 만들 수 있음
	- 명령을 활용해 일급 함수를 흉내낼 수 있음
	- 메서드와 필드를 활용해 복잡한 함수를 잘게 쪼갤 수 있다
#### 절차
1. 대상 함수의 기능을 빈 클래스로 옮긴다. 클래스 이름은 함수 이름에 기초해 짓는다
2. 방금 생성한 빈 클래스로 [[08. 기능 이동#1. 함수 옮기기|함수를 옮긴다]]
3. 함수의 인수들 각각은 명령의 필드로 만들어 생성자를 통해 설정할지 고민해본다

### 10. 명령을 함수로 바꾸기
#### 배경
- 명령은 함수를 하나 호출해 정해진 일을 수행하는 용도로 쓰인다
- 로직이 크게 복잡하지 않으면 명령 객체는 단점이 더 크니 평범한 함수로 바꾸는 편이 좋다
#### 절차
1. 명령을 생성하는 코드와 명령의 실행 메서드를 호출하는 코드를 함께 [[06. 기본적인 리팩터링#1. 함수 추출하기|함수로 추출]]한다
2. 명령의 실행 함수가 호출하는 보조 메서드들 각각을 [[06. 기본적인 리팩터링#2. 함수 인라인하기|인라인 한다]]
3. [[06. 기본적인 리팩터링#5. 함수 선언 바꾸기|함수 선언 바꾸기]]를 적용하여 생성자의 매개변수 모두를 명령의 실행 메서드로 옮긴다
4. 명령의 실행 메서드에서 참조하는 필드들 대신 대응하는 매개변수를 사용하게끔 바꾼다. 수정마다 테스트한다
5. 생성자 호출과 명령의 실행 메서드 호출을 호출자 안으로 인라인한다
6. 테스트한다
7. [[08. 기능 이동#9. 죽은 코드 제거하기|죽은 코드는 제거한다]]

### 11. 수정된 값 반환하기
#### 배경
- 값이 어떻게 수정되는지 추적하는 일은 어렵다
	- 따라서 데이터가 수정되면 명시적으로 알려줘야한다
- 변수를 갱신하는 함수가 변경된 값을 반환하고 변수가 변경된 값을 가지고 있으면 명시적으로 알 수 있다
	- 변수의 값이 단 한 번만 변경되는 경우 용이하다

#### 절차
1. 함수가 수정된 값을 반환하고, 변수가 그 값을 저장하게 한다
2. 테스트한다
3. 피호출 함수 안에 반환한 값을 가리키는 새로운 변수를 선언한다
4. 테스트한다
5. 선언과 동시에 계산이 이루어지도록 한다
6. 테스트한다
7. 피호출 함수의 변수 이름을 새 역할에 어울리게 변경한다
8. 테스트한다

### 12. 오류 코드를 예외로 바꾸기
#### 배경
- 예외를 던지면 오류 코드를 일일이 검사할 필요가 없어진다
- 예외는 프로그래밍 언어에서 제공하는 독립적인 오류 처리 메커니즘이다
	- 오류가 발생하면 예외를 던진다
	- 예외는 적절한 핸들러를 찾아 콜스택 위로 전파된다
	- 핸들러를 찾으면 적절히 처리된다
- 예외는 정상 밖의 동작일 때만 사용해야 한다
	- 예외를 던지는 코드를 프로그램 종료 코드로 바꿔도 프로그램이 여전히 정상 동작할 지를 따져보자
	- 정상 동작하지 않을 것 같으면 예외를 사용하지마라 - (웹 애플리케이션은 종료되면 안된다. 중간에 로직이 다 멈춰도 되는가를 고민해보자)
	- 지금 내가 작성하는 로직에서 사용하는 값들이 모두 정상적이어야 하는지, 그렇지 않을 수 있는지
		- 데이터베이스에 내가 직접 저장한 관리용 데이터는 무조건 정상이어야 한다
#### 절차
1. 콜스택 상위에 예외 핸들러를 만든다
2. 테스트한다
3. 해당 오류 코드를 대체할 예외와 그 밖의 예외를 구별할 방법을 찾는다
4. 정적 검사를 수행한다
5. catch 절을 수정하여 직접 처리할 수 있는 예외는 적절히 처리하고, 그렇지 않은 예외는 다시 던진다
6. 테스트한다
7. 오류 코드를 반환하는 곳 모두에서 예외를 던지도록 수정한다. 수정할 때마다 테스트한다
8. 모두 수정했다면 오류 코드를 콜 스택 위로 던지는 로직을 모두 제거한다

### 13. 예외를 사전 확인으로 바꾸기
#### 배경
- 예외는 말 그대로 예외적인 상황에 사용해야 한다
- 함수 수행 시 문제가 될 수 있는 조건을 사전에 검사할 수 있다면, 호출자에서 검사를 수행해야 한다
#### 절차
1. 예외를 유발하는 상황을 검사할 수 있는 조건문을 추가한다. catch 블록의 코드를 조건문의 조건절 중 하나로 옮기고, 남은 try 블록의 코드를 다른 조건절로 옮긴다
2. catch 블록에 어서션을 추가하고 테스트한다
3. try-catch 문을 제거한다
4. 테스트한다
