### 1. 메서드 올리기
#### 배경
- 중복 코드 제거는 위험하다
	- 중복이 있으면 중복사항이 반영되지 않는 곳이 발생할 수 있다
- 메서드들의 본문이 같으면 리팩터링을 적용하기 가장 쉽다
- 이 리팩터링의 선행 단계로 [[11. API 리팩터링#2. 함수 매개변수화 하기|함수를 매개변수화]]하고 메서드를 상위로 올릴 수도 있다
- 메서드의 본문에서 참조하고 있는 필드들이 서브 클래스에 있는 경우,  [[12. 상속 다루기#2.필드 올리기|필드를 먼저 슈퍼 클래스에 올린 후]]에 메서드를 상위로 올려야 한다
#### 절차
1. 똑같이 동작하는 메서드인지 확인한다. 다르면 같아질 때까지 리팩터링한다
2. 메서드 안에서 호출하는 함수와 필드가 슈퍼 클래스에서도 참조할 수 있는지 확인한다
3. 메서드 시그니처가 다르다면 [[06. 기본적인 리팩터링#5. 함수 선언 바꾸기|함수 선언 바꾸기]]로 슈퍼클래스에서 사용하고 싶은 형태로 통일한다
4. 슈퍼클래스에 새로운 메서드를 생성하고, 대상 메서드의 코드를 복사해 넣는다
5. 정적 검사를 수행한다
6. 서브클래스 중 하나의 메서드를 제거한다
7. 테스트한다
8. 모든 서브클래스의 메서드가 없어질 때까지 다른 서브클래스의 메서드를 하나씩 제거한다

### 2. 필드 올리기
#### 배경
- 상속 구조에서 필드가 중복되기 쉽다
	- 필드 이름이 같지 않을 수도 있어, 필드가 어떻게 쓰이는지 확인해야 한다
- 필드를 슈퍼클래스로 올리면 두 가지 중복을 제거할 수 있다
	- 데이터 중복 선언 제거
	- 필드를 사용하는 동작 중복 제거
#### 절차
1. 후보 필드가 어떻게 쓰이고 있는지 확인한다. 똑같으면 리팩터링 대상이된다
2. 필드의 이름이 서로 다르면 [[09. 데이터 조직화#2. 필드 이름 바꾸기|같은 이름으로 변경한다]]
3. 슈퍼클래스에 새로운 필드를 생성한다
4. 서브클래스의 필드들을 제거한다
5. 테스트한다

### 3. 생성자 본문 올리기
#### 배경
- 서브클래스에 같은 메서드가 있으면 [[06. 기본적인 리팩터링#1. 함수 추출하기|함수 추출하기]]와 [[12. 상속 다루기#1. 메서드 올리기|메서드 올리기]]를 적용한다
- 생성자는 메서드와 달리 제약이 있어 조금 다른식으로 접근해야 한다

> [!tip]
> 이 리팩터링이 쉽게 끝날 것 같지 않으면 생성자를 [[11. API 리팩터링#8. 생성자를 팩터리 함수로 바꾸기|생성자를 팩터리 함수로 바꾸기]]를 고려해본다

#### 절차
1. 슈퍼클래스에 생성자가 없다면 하나 선언한다. 서브클래스의 생성자들에서 이 생성자가 호출되는지 확인한다
2. [[08. 기능 이동#6. 문장 슬라이드하기|문장 슬라이드 하기]]로 공통 문장 모두를 `super()` 호출 직후로 옮긴다
3. 공통 코드를 슈퍼클래스에 추가하고 서브클래스는 제거한다. 생성자 매개변수 중 공통 코드에 참조하는 값들 모두 `super()`로 건넨다
4. 테스트한다
5. 생성자 시작 부분으로 옮길 수 없느 공통 코드에는 [[06. 기본적인 리팩터링#1. 함수 추출하기|함수 추출하기]]와 [[12. 상속 다루기#1. 메서드 올리기|메서드 올리기]]를 차례로 적용한다

### 4. 메서드 내리기
#### 배경
- 특정 서브클래스 하나(혹은 소수)와만 관련된 메서드는 슈퍼클래스에서 제거하고 서브클래스로 내리는 것이 깔끔하다
- 이 리팩터링을 적용하면 클라이언트에서 서브클래스를 정확히 알고 있어야 한다
#### 절차
1. 대상 메서드를 모든 서브클래스에 복사한다
2. 슈퍼클래스에서 그 메서드를 제거한다
3. 테스트한다
4. 이 메서드를 사용하지 않는 모든 서브클래스에서 제거한다
5. 테스트한다

### 5. 필드 내리기
#### 배경
- 특정 서브클래스 하나(혹은 소수)와만 관련된 필드 슈퍼클래스에서 제거하고 서브클래스로 내리는 것이 깔끔하다\
#### 절차
1. 대상 필드를 모든 서브클래스에 복사한다
2. 슈퍼클래스에서 그 필드를 제거한다
3. 테스트한다
4. 이 필드를 사용하지 않는 모든 서브클래스에서 제거한다
5. 테스트한다 
### 6. 타입 코드를 서브클래스로 바꾸기
#### 배경
- 소프트웨어 시스템에서 비슷한 대상을 특성에 따라 나누는 방법으로 **타입 코드**가 있다
- 타입 코드는 상황에 따라 부족함이 있다. 이때 서브클래스로 바꿀 수 있다
- 서브클래스의 장점
	- 조건에 따라 다르게 동작하도록 하는 **다형성**을 제공한다([[10. 조건부 로직 간소화#4. 조건부 로직을 다형성으로 바꾸기|조건부 로직을 다형성으로 바꾸기]]). 
	- 특정 타입에서만 필요한 필드를 서브클래스가 갖도록 할 수 있다([[12. 상속 다루기#5. 필드 내리기|필드 내리기]])
- 리팩터링 대상
	- 대상 클래스
		- 직원의 하위 타입인 엔지니어, 마케터
		- 간단하다
		- 업무 유형을 다른 방식으로 사용하고 싶을 때 사용하지 못한다
		- 유형이 불변일 때 사용하지 못한다
		- [[07. 캡슐화#3. 기본형을 객체로 바꾸기|기본형을 객체로 바꾸기]]를 적용하여 직원 유형 클래스르 만든 후 리팩터링을 적용한다
	- 타입 코드 자체
		- 직원 유형의 '속성'을 부여. 엔지니어링, 마케팅

#### 절차
1. 타입 코드 필드를 자가 캡슐화한다
2. 타입 코드 값 하나를 선택하여 서브클래스를 만든다. 타입 코드 게터를 오버라이딩하여 타입 코드 리터럴을 반환하도록 한다
3. 매개변수로 받은 타입 코드와 방금 만든 서브클래스를 매핑하는 로직을 만든다
	   - 직접 상속인 경우 [[11. API 리팩터링#8. 생성자를 팩터리 함수로 바꾸기|생성자를 팩터리 함수로 바꾸기]]를 적용
	   - 간접 상속인 경우 선택 로직을 생성자에 둔다
4. 테스트 한다
5. 타입 코드 값 각각에 대해 서브클래스 생성과 선택 로직을 추가한다. 클래스가 완성될 때마다 테스트한다
6. 타입 코드 필드를 제거한다
7. 테스트한다
8. 타입 코드 접근자를 이용하는 메서드 모두에 [[12. 상속 다루기#4. 메서드 내리기|메서드 내리기]]와 [[10. 조건부 로직 간소화#4. 조건부 로직을 다형성으로 바꾸기|조건부 로직을 다형성으로 바꾸기]]를 적용한다
### 7. 서브클래스 제거하기
#### 배경
- 소프트웨어가 성장하면서 서브클래스가 다른 모듈로 이동하거나, 아에 사용되지 않거나, 필요로하는 방식으로 만들어진 기능에서 사용할 수 있다
- 이런 경우에는 서브클래스를 제거하는 편이 낫다
#### 절차
1. 서브클래스의 [[11. API 리팩터링#8. 생성자를 팩터리 함수로 바꾸기|생성자를 팩터리 함수로 바꾼다]]
2. 서브클래스의 타입을 검사하는 로직은 슈퍼클래스로 옮긴다
3. 서브클래스의 타입을 나타내는 필드를 슈퍼클래스에 만든다
4. 서브클래스를 참조하는 메서드가 방금 만든 타입 필드를 시용하도록 수정한다
5. 서브클래스를 지운다
6. 테스트한디

### 8. 슈퍼클래스 추출하기
#### 배경
- 비슷한 일을 하는 두 클래스가 보이면 비슷한 부분을 공통의 슈퍼 클래스로 옮겨 담을 수 있다
- 필드라면 [[12. 상속 다루기#2. 필드 올리기|필드 올리기]], 동작이라면 [[12. 상속 다루기#1. 메서드 올리기|메서드 올리기]]를 적용한다
- 슈퍼클래스 추출하기의 대안은 [[07. 캡슐화#5. 클래스 추출하기|클래스 추출하기]]가 있다
	- 동작을 상속으로 해결하느냐, 위임으로 해결하느냐의 차이다
	- [[12. 상속 다루기#11.슈펴클래스를 위임으로 바꾸기|슈퍼클래스를 위임으로 바꾸기]]는 어렵지 않아서, 먼저 슈퍼클래스 추출하기를 적용해보는 것이 좋다
#### 절차
1. 빈 슈퍼클래스를 만든다. 원래의 클래스들이 새 클래스를 상속하도록한다
2. 테스트한다
3. [[12. 상속 다루기#3. 생성자 본문 올리기|생성자 본문 올리기]], [[12. 상속 다루기#1. 메서드 올리기|메서드 올리기]], [[12. 상속 다루기#2. 필드 올리기|필드 올리기]]를 차례로 적용하여 공통 원소를 슈퍼 클래스로 옮긴다
4. 서브클래스에 남은 메서드들을 검토한다. 공통되는 부분이 있다면 [[06. 기본적인 리팩터링#1. 함수 추출하기|함수로 추출한]] 다음 [[12. 상속 다루기#1. 메서드 올리기|메서드 올리기]]를 적용한다
5. 원래 클래스들을 사용하는 코드를 검토하며 슈퍼클래스의 인터페이스를 사용하게 할지 고민해본다
### 9. 계층 합치기
#### 배경
- 계층구조도 진화하면서 어떤 클래스가 부모와 비슷해져 더 이상 독립적으로 존재할 이유가 사라지는 경우가 있다
#### 절차
1. 두 클래스 중 제거할 것을 고른다
2. [[12. 상속 다루기#3. 생성자 본문 올리기|생성자 본문 올리기]], [[12. 상속 다루기#1. 메서드 올리기|메서드 올리기]], [[12. 상속 다루기#2. 필드 올리기|필드 올리기]]를 적용하여 모든 요소를 하나의 클래스로 옮긴다
3. 제거할 클래스를 참조하던 모든 코드가 남겨질 클래스를 참조하도록 고친다
4. 빈 클래스를 제거한다
5. 테스트한다
### 10. 서브클래스를 위임으로 바꾸기
#### 배경
- 갈래에 따라 동작이 달라지는 객체들은 상속으로 표현하는 것이 자연스럽다
- 상속의 단점
	- 달라져야 하는 이유가 여러개여도 단 하나의 기준을 선택해야 한다
	- 클래스들의 관계를 긴밀하게 결합한다
		- 부모를 수정하면 자식에 영향을 미칠 수 있다
- 위임은 상속의 단점을 해결해준다
	- 다양한 클래스에서 서로 다른 이유로 위임할 수 있다
	- 상속보다 결합이 약하다
- '상속 보다는 컴포지션을 사용하라'
	- 상속을 절대 사용하지 말라는 것은 아니다
	- 필요하면 언제든 서브클래스를 위임으로 바꿀 수 있다
#### 절차
1. 생성자를 호출하는 곳이 많다면 [[11. API 리팩터링#8. 생성자를 팩터리 함수로 바꾸기|생성자를 팩터리 함수로 바꾼다]]
2. 위임으로 활용할 빈 클래스를 만든다. 서브클래스에 특화된 데이터를 전부 받아야 한다. 슈퍼클래스를 가리키는 **역참조**도 필요하다
3. 위임을 저장할 필드를 슈퍼클래스에 추가한다
4. 서브클래스 생성 코드를 수정하여 위임 인스턴스를 생성하고 위임 필드에 대입해 초기회한다
5. 서브클래스의 메서드 중 위임 클래스로 이동할 것을 고른다
6. [[08. 기능 이동#1. 함수 옮기기|함수 옮기기]]를 적용해 위임 클래스로 옮긴다. 원래 메서드에서 위임하는 코드는 지우지 않는다
7. 서브클래스 외부에도 원래 메서드를 호출하는 코드가 있다면 서브클래스 위임 코드를 슈퍼클래스로 옮긴다. 위임이 존재하는지 검사하는 보호 코드로 감싸야 한다. 호출하는 외부 코드가 없다면 원래 메서드는 [[08. 기능 이동#9. 죽은 코드 제거하기| 죽은 코드가 되므로 제거한다]]
   - 서브클래스가 둘 이상이고 서브클래스에서 중복이 생겨나기 시작한다면 [[12. 상속 다루기#8. 슈퍼클래스 추출하기|슈퍼클래스를 추출한다]]
   - 기본 동작이 슈퍼 위임 클래스로 옮겨졌다면 슈퍼클래스의 위임 메서드들에는 보호 코드가 필요 없다
8. 테스트한다
9. 서브클래스의 모든 메서드가 옮겨질 때까지 5~8 과정을 반복한다
10. 서브클래스들의 생성자를 호출하는 코드를 찾아서 슈퍼클래스의 생성자를 사용하도록 수정한다
11. 테스트한다
12. 서브클래스를 삭제한다

### 11. 슈퍼클래스를 위임으로 바꾸기
#### 배경
- 자바의 스택은 상속을 잘못 사용한 예이다
	- 리스트를 상속하여 불필요하 리스트의 연산이 노출되고 있다
- 제대로된 상속이라면 서브클래스가 슈퍼클래스의 모든 기능을 사용하고, 서브클래스의 인스턴스를 슈퍼클래스의 인스턴스로도 취급할 수 있어야 한다
	- [타입-인스턴스 동형이의어](https://martinfowler.com/bliki/TypeInstanceHomonym.html) 모델링 실수를 피하자
- 상속은 의미상 적합한 조건이라면 간단하고 효과적인 메커니즘이다
	- 상속을 먼저 적용하고 나중에 슈퍼클래스를 위임으로 바꾸는 것이 좋다
#### 절차
1. 슈퍼클래스 객체를 참조하는 필드를 서브클래스에 만든다. 위임 참조를 새로운 슈퍼클래스 인스턴스로 초기화한다
2. 슈퍼클래스의 동작 각각에 대응하는 전달 함수를 서브클래스에 만든다. 서로 관련된 함수끼리 그룹으로 묶어 진행한다. 그룹을 하나씩 만들때마다 테스트한다
3. 슈퍼클래스의 동작 모두가 전달 함수로 오버라이드됐다면 상속 관계를 끊는다
