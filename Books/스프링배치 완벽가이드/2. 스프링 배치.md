## 1. 배치 아키텍처
- 애플리케이션 레이어: 개발자가 개발한 코드. 대부분 코어레이어와 상호작용
- 코어 레이어: 배치 영역을 구성하는 여러 컴포넌트
- 인프라스트럭쳐 레이어: ItemReader, ItemWriter  및 재시작과 관련된 문제를 해결할 수 있는 클래스와 인터페이스
### 잡과 스텝
- **잡**: 상태를 수집하고 이전 상태에서 다음 상태로 전환. 개념적으로 **상태 기계(State Machine)**
- **스텝**: 잡을 구성하는 독립적인 작업 단위. 태스크릿 기반, 청크 기반 스텝이 존재
	- **태스크릿**: 청크 기반 스텝보다 간단. 스텝이 중지 될 때까지 execute가 계속 실행. 알림 전송 등 간단한 작업에 사용
	- **청크**: 아이템 기반 처리에 사용. ItemReader, ItemProcessor(Optional), ItemWriter로 이루어 질 수 있다.
- 스텝 분리의 이점
	- 유연성: 스프링 배치가 개발자에게 재사용 가능한 여러 빌더 클래스를 사용해 개발자는 유연하게 스텝을 구성할 수 있다
	- 유지 보수성: 스텝간 독립적이어서 재사용 및 테스트가 용이하다
	- 확장성: 독립적인 스텝은 확장 가능한 다양한 방법(병렬 실행 등)을 제공한다.
	- 신뢰성: 스텝의 여러 단계에 강력한 오류 처리 방법(재시도, 건너뛰기)을 제공한다
### 잡 실행
- **JobRepository**: 다양한 배치 수행과 관련된 수치 데이터(시작 시간, 종료 시간, 상태, 읽기/쓰기 횟수) 및 잡의 상태를 유지 관리
- **JobLauncher**: `Job.execute`를 호출하여 잡을 실행, 잡의 재시도 가능 검증, 잡의 실행 방법, 파라미터 유효성 처리등 수행
- 잡과 스텝의 실행 방식
	- 잡은 구성된 스텝 목록에 따라 스텝을 실행
	- 스탭내 청크의 처리가 완료되면  JobRepository내 JobExecution, StepExecution을 현재 상태로 업데이트
		- 스텝은 ItemReader가 읽은 아이템을 따라간다. 스텝이 각 청크를 처리할 때 마다 JobRepository내  StepExecution이 업데이트된다
	- 잡과 스텝이 완료되면 JobRepository내 JobExecution, StepExecution이 최종 상태로 업데이트된다
- 잡과 스텝의 스프링 배치 구현 관계
	- Job `-*>` JobInstance `-*>` JobExecution `-*>` StepExecution
### 병렬화
- 다중 스레드 스텝을 통한 작업 분할, 전체 스텝의 병렬실행, 비동기 ItemProcessor/ItemWriter 구성, 원격 청킹, 파티셔닝

#### 다중 스레드 스텝
- 한 스텝에서 여러 스레드를 사용해 청크 단위로 병렬화
#### 병렬 스텝
- 서로 관련이 없는 독립된 스텝을 병렬화
#### 비동기 ItemProcessor/ItemWriter
- AsynchronousItemProcessor, AsynchronousItemWriter를 사용
- AsynchronousItemProcessor는 Future를 반환하여 AsynchronousItemWriter에 전달
#### 원격 청킹
- 마스터 노드와 워커 노드로 구성
- 마스터 노드에서 ItemReader를 통해 읽은 데이터를 메시지 브로커를 통해 원격 브로커 ItemProcessor에 전달
- 워커에서 처리가 완료된 데이터는 다시 마스터 노드에 전달
- 네트워크 사용량이 많아질 수 있어, I/O 비용이 적은 시나리오에 적합하다
#### 파티셔닝
- 원격 파티셔닝과 로컬 파티셔닝
	- 원격  파티셔닝은 원격 워커를 사용, 로컬 파티셔닝은 로컬 워커 스레드 사용
- 마스터 스텝이 데이터를 분할하여 워커 스텝에 전달, 워커 스텝은 작업을 수행
	- 마스터는 스텝 수집을 위한 컨트롤러 역할만 수행
	- 모든 워커 스텝이 작업을 완료하면 스텝이 완료된 것으로 간주
