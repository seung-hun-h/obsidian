'최소 한 번' 전달 한다는 것의 의미에는 메시지가 중복될 수 있다는 것을 내포한다. 이벤트를 집적하는 애플리케이션은 '최소 한 번'이 아니라 '정확히 한 번'의 구조를 필요로 한다. 카프카의 '정확히 한 번'의 의미 구조는 두 가지 핵심기능(멱등적 프로듀서, 트랜잭션)을 통해 달성할 수 있다

# 1. 멱등적 프로듀서 
**멱등적**
- 멱등적(idempotent)라는 것은 동일한 작업을 여러번 실행한 것과 한 번 실행한 것의 결과가 동일한 것을 의미한다
**멱등적 프로듀서**
- 카프카의 멱등적 프로듀서는 메시지의 중복을 탐지하고 처리한다
## 1. 멱등적 프로듀서의 작동원리
- 멱등적 프로듀서 기능을 켜면, 모든 메시지에 **프로듀서 ID**와 **시퀀스 넘버**를 조합한 고유한 **식별자**를 가지게된다
	- `max.in.flights.requests.per.connection` 값에 따라 추적하고자 하는 시퀀스 넘버의 수를 제한한다
- 브로커는 중복된 식별자를 가진 메시지를 받게될 경우 에러를 발생시킨다
- 브로커가 예상된 시퀀스 넘버보다 높은 시퀀스 넘버를 받을 경우 'out of order sequnece number' 에러를 발생시킨다
##### 1. 프로듀서가 재시작한 경우
- 멱등적 프로듀서 기능을 켠 경우, 프로듀서는 초기화 과정에서 프로듀서 ID를 생성 받는다
	- 켜지 않은 경우, 생성 받지 않는다
- 트랜잭션 기능을 켜지 않은 경우, 프로듀서를 초기화할 때마다 완전히 새로운 ID가 생성된다
	- 새 프로듀서가 기존 프로듀서와 같은 메시지를 전송해도 브로커는 알아차리지 못한다
##### 2. 브로커에 장애가 발생한 경우
- Kafka의 리더와 팔로워는 메시지를 처리할 때 **시퀀스 넘버**를 메모리에 저장해 **멱등성**을 유지한다
	- 리더는 메시지를 쓸 때마다 인-메모리 프로듀서 상태에 시퀀스 넘버를 업데이트한다
	- 팔로워는 리더의 메시지를 복제할 때마다 인-메모리 버퍼를 업데이트한다
- **스냅샷**은 프로듀서 상태를 파일로 저장하며, 장애가 발생한 리더가 복구될 때 이를 읽고 상태를 복원한다
- 스냅샷이 업데이트 되지 못한 경우, 오래된 스냅샷과 최신 세그먼트 메시지를 사용해 상태를 복구한다
- 복구된 브로커에 메시지가 없으면, 중복 문제가 없으므로 즉시 새 메시지 처리를 시작한다
## 2. 멱등적 프로듀서의 한계
- 멱등적 프로듀서는 **프로듀서 내부 로직**으로 재시도가 발생한 경우 생기는 중복만을 방지한다
- 동일한 메시지에 대해 `producer.send()`가 여러번 호출된 경우는 방지하지 못한다
## 3. 멱등적 프로듀서 사용법
- `enable.idempotence=true`

**변경되는 사항들**
- 프로듀서 ID 조회를 위해 API를 한 번 더 호출한다
- 레코드 배치에 프로듀서 ID와 배치 내 첫 메시지의 시퀀스 넘버가 포함된다. 각 메시지 배치에 96비트를 추가한다
- 브로커들은 모든 프로듀서 인스턴스에서 들어온 레코드 배치의 시퀀스 넘버를 검증하여 중복을 방지한다
- 장애가 발생하더라도 각 파티션에 쓰여지는 메시지 순서는 보장된다
	- **시퀀스 넘버**를 통해 메시지의 순서가 보장된다
	- **중복 메시지가 무시**되므로 데이터가 중복 기록되지 않는다
	- 장애가 발생해도 **스냅샷과 최신 메시지를 활용한 복구 메커니즘** 덕분에 메시지 순서가 유지된다
# 2. 트랜잭션
- 카프카의 트랜잭션 기능은 스트림 처리 애플리케이션이 정확한 결과를 산출하도록 한다
- 카프카의 트랜잭션은 '읽기-처리-쓰기' 패턴에서 사용하도록 개발되었다
## 1. 트랜잭션 활용 사례
- 정확성이 중요한 애플리케이션에 언제나 도움된다
- 다수의 레코드를 집적하는 등 복잡한 스트림 처리 애플리케이션에 활용된다
## 2. 트랜잭션이 해결하는 문제
- 메시지를 처리하고 결과를 썼지만 오프셋을 커밋하지 못해 중복처리 된 경우
- 정지된 애플리케이션이 다시 작동하여 중복처리 된 경우
## 3. 트랜잭션은 어떻게 '정확히 한 번'을 보장하는가?
#### 1. 프로듀서
- **원자적 다수 파티션 쓰기**
	- 트랜잭션 프로듀서를 사용하면, 결과를 파티션에 쓰는것과 오프셋을 커밋하여 파티션에 쓰는 것을 원자적으로 할 수 있다
	- 트랜잭션 프로듀서는 `transaction.id` 설정을 잡아주어야 한다. 재시작을 하더라도 이 값은 유지된다
	- 브로커는 `transaction.id`와 `producer.id`의 쌍을 유지하다가 `initTransactions()`를 프로듀서가 다시 호출하면 이전에 쓰던 `producer.id`를 할당해준다
- **좀비 펜싱**
	- `initTransactions()`를 프로듀서가 호출하면 `transaction.id`의 에포크(epoch)를 증가시킨다
	- 에포크가 낮은 프로듀서가 메시지를 전송하면, `FencedProducer`에러가 발생하면서 거부된다
#### 2. 컨슈머
- 트랜잭션 격리 수준을 조절한다
- **read_committed**
	- 커밋된 트랜잭션이 속한 메시지나 처음부터 트랜잭션에 속하지 않은 메시지만 리턴한다
	- 아직 진행중인 트랜잭션이 처음으로 시작된 시점(Last Stable offset, LSO) 이후에 쓰여진 메시지는 리턴하지 않는다
- **read_uncommitted**
	- 진행중이거나 중단된 트랜잭션에 속한 것을 포함한 모든 레코드가 리턴된다
## 4. 트랜잭션으로 해결할 수 없는 문제들
- 트랜잭션은 카프카 내부에서 쓰기 작업이 이루어진 것들만 '정확히 한 번'을 보장한다
- 부수 효과(이메일 전송), 외부 시스템(데이터베이스)에 대한 쓰기, 클러스터 복제, 발행/구독 패턴 등의 경우에는 트랜잭션이 보장되지 않는다
	- 발행/구독 패턴: 여러 구독자를 카프카가 관리하지 않으므로, 구독자간 차이가 발생할 수 있다
## 5. 트랜잭션 사용법
- 카프카 스트림즈를 사용하는 경우, `exactly-once` 보장 활성화
- 카프카 스트림즈를 사용하지 않는 경우, 트랜잭션 API를 직접 사용
## 6. 트랜잭션 ID와 펜싱
- 2.5 이전
	- 트랜잭션 ID를 파티션에 정적으로 대응시킨다
	- 프로듀서 A가 토픽 T에 메시지를 쓰다가 연결이 끊어지고, 프로듀서 B가 새로들어 온 후, 프로듀서 A가 다시 연결이 활성화되면 A와 B의 트랜잭션 ID가 달라 펜싱되지 않는다
- 2.5 이후
	- Kafka 2.5 이후, 트랜잭션 ID와 컨슈머 그룹 메타데이터를 함께 사용하는 펜싱 기법이 됐다
	- 프로듀서가 오프셋 커밋 메서드를 호출할 때 브로커에 컨슈머 그룹 메타데이터(Consumer Group Metadata)를 전달합니다. 이를 통해 브로커는 프로듀서가 현재 컨슈머 그룹의 최신 상태와 일치하는지 확인할 수 있다
	- 프로듀서 A가 토픽 T에 메시지를 쓰다가 연결이 끊어지고, 프로듀서 B가 동일한 트랜잭션 ID를 사용해 새로운 연결을 설정하면, Kafka는 트랜잭션 ID와 컨슈머 그룹 메타데이터를 업데이트하여 프로듀서 B를 트랜잭션의 소유자로 설정한다
	- 이후, 프로듀서 A가 다시 연결을 시도할 때, Kafka는 컨슈머 그룹 메타데이터를 확인하여 프로듀서 A의 정보가 이전 세대의 상태임을 감지하고 연결을 거부(펜싱)한다
## 7. 트랜잭션 작동 원리
- **찬디-램포트 스냅샷 알고리즘**의 영향을 받았다
**과정**
1. 현재 진행중인 트랜잭션이 존재함을 연관된 파티션과 함께 로그에 기록한다
2. 로그에 커밋 혹은 중단 시도를 기록한다
3. 모든 파티션에 트랜잭션 마커를 쓴다
4. 트랜잭션이 종료되었음을 로그에 쓴다

**알고리즘의 실제 동작**
1. 트랜잭션을 시작하기전, 프로듀서는 `initTransaction()`을 호출해 자신이 트랜잭션 프로듀서임을 등록한다
2. 코디네이터에 새 트랜잭션 ID를 등록하거나, 기존 ID의 에포크를 증가시킨다
3. `beginTransaction()`을 호출한다. 단순히 현재 진행중인 트랜잭션이 있다는 사실을 알린다. 
4. 프로듀서가 레코드 전송을 시작하면, 프로듀서는 브로커에 `AddPartitionsToTxn` 요청을 보내 현재 이 프로듀서에 진행중인 트랜잭션이 있음을 알리고, 레코드가 추가되는 파티션들이 트랜잭션의 일부임을 알린다
5. 쓰기 작업이 완료되고 커밋할 준비가 되면, 이 트랜잭션에서 처리한 레코드들의 오프셋부터 커밋한다. 오프셋은 트랜잭션이 커밋되기전 커밋해야 한다. `sendOffsetsToTransaction()`을 호출하면, 트랜잭션 코디네이터로 오프셋과 컨슈머 그룹 ID가 포함된 요청이 전송된다. 트랜잭션 코디네이터는 컨슈머 그룹 ID를 사용해서 컨슈머 그룹 코디네이터를 찾은 뒤, 오프셋을 커밋한다
6. `commitTransaction()` 혹은 `abortTransaction()`을 호출하여 트랜잭션 코디네이터에 `EndTx` 요청이 전송된다
7. 코디네이터는 트랜잭션 로그에 커밋 혹은 중단 시도를 기록한다
8. 코디네이터는 트랜잭션에 포함된 모든 파티션에 커밋 마커를 쓴 다음, 트랜잭션 로그에 커밋이 성공적으로 완료되었음을 기록해 넣는다. 만약 중간에 크래쉬가 나면 다른 코디네이터가 선출되어 작업을 마무리한다
9. `transaction.timeout.ms` 시간안에 커밋 혹은 중단이 마무리되지 않으면 코디네이터는 트랜잭션을 자동으로 중단한다
# 3. 트랜잭션 성능
**프로듀서**
- 트랜잭션 ID 요청 최초 한 번
- 트랜잭션의 일부로써 파티션을 등록하는 요청 각 파티션당 한 번
- 각 트랜잭션이 커밋 요청을 전송하면, 파티션마다 커밋 마커 추가
- 트랜잭션 초기화와 커밋 요청은 동기적으로 작동
- 트랜잭션 오버헤드는 트랜잭션에 포함된 메시지 수와는 무관한다. 트랜잭션마다 많은 수의 메시지를 집어넣는 쪽이 상대적으로 오버헤드가 적다
**컨슈머**
- 커밋 마커를 읽어오는 작업에 관련해서 오버헤드가 약간 있다. 트랜잭션 커밋 사이의 간격이 길어질수록 컨슈머는 메시지가 리턴될 때까지 더 오랫동안 기다려야 한다
- 트랜잭션에 속하는 메시지들을 버퍼링할 필요는 없다. 트랜잭션 데이터를 읽을 때 컨슈머는 추가적인 작업이 필요 없다
