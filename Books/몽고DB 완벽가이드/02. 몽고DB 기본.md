## 1. 도큐먼트
- 몽고DB의 핵심은 정렬된 키와 연결된 값의 집합으로 이루어진 **도큐먼트**
- 도큐먼트의 키는 문자열
	- 키는 `\0`(null 문자)를 포함하지 않는다
	- `.`, `%$`를 포함한 예약어를 사용할 수 없다
- 몽고DB는 데이터형과 대소문자를 구별
	- `5`와 `"5"`는 다르다
- 몽고DB에서는 키가 중복될 수 없음
## 2. 컬렉션
- 컬렉션은 **도큐먼트의 모음**
### 1. 동적 스키마
- 컬렉션은 동적 스키마를 가진다
	- 컬렉션 내 서로 다른 형식의 도큐먼트를 저장할 수 있다
- 여러 컬렉션을 사용하는 이유
	- 컬렉션에서 다른 종류의 컬렉션을 반환하면 애플리케이션 로직이 복잡해진다
	- 컬렉션 별로 목록을 뽑으면 한 컬렉션 내에서 특정 데이터형별로 쿼리하는 것 보다 빠르다
	- 데이터 지역성에 좋다
	- 인덱스는 컬렉션 별로 정의하는데 인덱스를 만들면 도큐먼트는 특정 구조를 지녀야 한다. 다른 형식의 도큐먼트를 컬렉션별로 분리하면 인덱스를 만드는데 도움이 된다.
### 2. 네이밍
- 빈문자열("")을 사용할 수 없다
- `\0`(null 문자)를 사용할 수 없다
- 예약어를 사용할 수 없다
#### 서브 컬렉션
- 마침표(`.`)를 사용해 컬렉션을 체계화할 수 있다
- 체계화를 위함이지 상위나 자식 컬렉션과 연관성을 지니는 것은 아니다
- 몽고DB 툴에서 자체적으로 기능을 제공하기는 한다
## 3. 데이터베이스
- 몽고DB는 데이터베이스에 컬렉션을 그룹화할 수도 있다
- 데이터베이스는 완전히 독립적으로 취급될 수 있다
- 데이터베이스 이름
	- 빈문자열은 사용할 수 없다
	- `/\.''*<>:?$`, `\0`을 사용할 수 없다
	- 대소문자를 구별한다
	- 최대 64바이트다
## 4. 데이터형
### 1. 기본 데이터형
- null
- 불리언
- 숫자
	- 기본은 64비트 부동소수점 수 `{"x": 3.14}`
	- 4바이트 혹은 8바이트 부호 정수는 `NumberInt`, `NumberLong`을 사용한다.
		- `{"x": NumberInt("3")}`, `{"x": NumberLong("3")}`
- 문자열
- 날짜
- 정규 표현식
- 배열
- 내장 도큐먼트
- 객체 ID
- 이진 데이터
- 코드
	- 임의의 자바스크립트 코드를 포함할 수 있다
### 2. 날짜
- 새로운 `Date`객체를 생성하기 위해서는 항상 `new Date()`를 호출해야 한다
### 3. 배열
- 배열은 정렬 연산(리스트, 스택, 큐)과 비정렬 연산(셋)에 호환성있게 사용할 수 있는 값
- "몽고DB는 배열 구조를 이해한다"
	- 배열 내부에 도달하는 방법을 안다
	- 배열에 쿼리하거나 배열의 내용을 이용해 인덱스를 만들 수 있다
```javascript
db.users.insertMany([
  { _id: 1, name: "Alice", hobbies: ["reading", "cooking", "hiking"] },
  { _id: 2, name: "Bob", hobbies: ["gaming", "cooking"] }
]);


db.users.find({ hobbies: "cooking" }); // 배열에 쿼리
db.users.createIndex({ hobbies: 1 }); // 배열에 인덱스
```

### 4. 내장 도큐먼트
- 키에 대한 값으로 존재하는 도큐먼트를 내장 도큐먼트라 한다
- "몽고DB는 내장 도큐먼트를 이해한다"
	- 내장 도큐먼트 내부에 도달하는 방법을 안다
	- 내장 도큐먼트에 쿼리하거나 내장 도큐먼트의 내용을 이용해 인덱스를 만들 수 있다
```javascript
db.customers.insertOne({
  _id: 1,
  name: "John Doe",
  contact: {
    email: "john@example.com",
    phone: "1234567890"
  }
});

db.customers.find({ "contact.email": "john@example.com" });
```
- 내장 도큐먼트는 RDB에서 따지면 서로 다른 테이블을 조인하는 것이다. 하지만 몽고DB에서는 도큐먼트를 내장하고 있으므로 데이터 중복이 발생할 수 있다.
### 5.  `_id`와 ObjectId
- 모든 도큐먼트는 `_id`를 가진다
- `_id`는 컬렉션 내의 도큐먼트를 고유하게 식별한다
#### ObjectIds
- ObjectId는 `_id`의 기본 데이터형이다
- ObjectId는 몽고DB의 샤딩된 환경에서 고유 식별자를 생성하기 위해 사용한다
	- 각 샤드가 자체적으로 생성한다
- ObjectId는 12바이트를 사용한다
	- 0-3바이트: 1970년 1월 1일부터 시간을 1/1000초 단위로 저장하는 타임스탬프
		- 다음 5바이트와 묶일 때 초 단위의 유일성 제공
		- 대략 입력한 순서대로 정렬
		- 각 도큐먼트가 생성된 때의 잠재적인 타임스탬프
	- 4-8바이트: 프로세스당 한 번씩 생성되는 랜덤 값
	- 9-11바이트: 랜덤 값으로 시작하는 카운터
		- 서로 다른 시스템에서 충돌하는 ObjectId를 생성하지 않도록 함
#### `_id` 자동생성
- 도큐먼트를 입력할 때 `_id`를 명시적으로 입력하지 않으면 키가 지동으로 추가된다