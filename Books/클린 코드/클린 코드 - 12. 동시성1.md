다중 스레드를 제대로 구현하는 것은 어렵다. 하지만 다중 스레드를 통한 동시성은 결합을 없애는 훌륭한 전략이다. 동시성은 무엇(What)과 언제(When)을 분리한다.

결합을 분리하는 전략으로 동시성을 적용한다면 애플리케이션의 구조를 개선할 수 있고, 애플리케이션의 응답 시간과 작업 처리량을 개선할 수 있다

#### 애플리케이션 구조개선
웹 애플리케이션에서 표준으로 사용하는 '서블릿 모델'은 동시성을 적용한 모델이다. 서블릿은 웹 컨테이너에 의해서 관리되는데, 컨테이너는 동시성을 부분적으로 관리한다. 웹 요청이 들어올 때 마다 웹 서버는 서블릿을 비동기적으로 실행한다.

서블릿은 다른 서블릿과 독립적으로 동작하게되며, 서블릿 프로그래머는 웹 요청을 관리할 필요가 없어진다. 하지만 웹 컨테이너에서 제공하는 결합분리는 완벽하지 않고, 서블릿 프로그래머는 동시성에 유의하여 프로그래밍 해야 한다.
#### 응답 시간과 작업 처리량 개선
웹에서 정보를 가져와 요약하는 정보 수집기를 예로 들어보자. 단일 스레드 정보 수집기는 한 번에 한 웹 사이트에 대한 정보를 수집하고 요약한 후 다음 사이트로 넘어가게 된다. 이 경우 스레드의 웹 소켓에서 입출력을 위한 대기 시간이 길어질 것이다. 다중 스레드로 구현하게 된다면 수집기의 성능을 높일 수 있다. 또한 대량의 데이터를 처리하는 경우 다중 스레드를 활용해 병렬로 처리하기 된다면 데이터 처리량이 개선될 것이다.

#### 동시성의 단점
동시성이 항상 시스템의 성능을 개선하는 것은 아니다. 동시성의 단점은 다음과 같다
- 동시성은 시스템에 부하를 유발한다
- 동시성은 복잡하다
- 동시성 버그 재현이 어렯다
- 동시성 구현을 위해 근본적인 설계 전략을 재고해야 한다

아래 클래스를 살펴보자

```Java
public class X {
	private int lastIdUsed;

	public int getNextId() {
		return ++lastIdUsed;
	}
}
```

두 개 이상의 스레드가 `X`의 인스턴스를 공유한다고 생각해보자. 언뜻 보면 문제가 없을 것 같지만, 문제가 발생할 수 있는 코드이다. 자바의 `++`연산은 원자적이지 않다. 값을 증가하고 할당하는 코드가 바이트 코드 수준에서 보면 분리되어 있다. 그러므로 경우에 따라서 의도하지 않은 값이 `lastIdUsed`에 할당될 수 있다.

### 동시성 방어
#### 동시성 방어 원칙: 단일 책임 원칙
동시성에서 발생하는 문제를 방어하기 위해서는 무엇보다 '단일 책임 원칙'을 준수해야 한다. 동시성 관련 코드는 다른 코드와 분리해야 한다는 것이다.

##### 동시성 방어 원칙: 자료 범위 제한
임계 영역은 두 스레드가 동시에 간섭하게 되므로 예상치 못한 결과를 내놓을 수 있다. 따라서 자바의 경우 `sychronized` 키워드를 사용해 임계 영역을 보호한다. 

임계 영역의 개수가 많아지면 시스템 전체의 처리량 혹은 응답성이 줄어들 수 있다. 임계 영역의 개수를 줄이기 위해 임계 영역의 크기를 늘린다면 스레드간 경쟁이 늘어나서 프로그램 성능이 저하될 수 있다.

따라서 임계 영역의 개수를 적게 그리고 작게 유지하는 것이 좋다

##### 동시성 방어원칙: 자료 사본
처음부터 공유 자료를 사용하지 않는 편이좋다. 어떤 경우에는 자료의 사본을 만들고 사본을 읽기 전용으로 사용하는 편이 좋다. 또 다른 경우에는 각 스레드가 객체를 복사해 사용한 후, 한 스레드가 사본의 결과를 가져와 동기화하는 방법도 있다.

##### 동시성 방어원칙: 독립적인 스레드
스레드를 독립적으로 구현한다면 각 스레드간 동기화가 필요 없다.

#### 라이브러리 사용
자바에서는 동시성을 위한 여러 라이브러리를 제공한다. 따라서 동시성 프로그래밍을 해야할 경우에는 해당 라이브러리를 이해하고 적절히 사용하는 것이 좋다. 

자바로 스레드 코드를 구현하기 위해서는 다음을 고려하는 것이 좋다.
- [[스레드 환경에 안전한 컬렉션]]을 사용한다
- 독립적인 작업을 수행할 때는 [[Executor 프레임워크]]를 사용한다
- 스레드가 차단(Blocking)되지 않는 방법을 사용한다

그리고 `java.util.concurrent`, `java.util.concurrent.atomic`, `java.util.concurrent.locks`을 이해하고 익히는 것이 좋다.

#### 실행 모델이해
다중 스레드 프로그래밍에서 사용하는 실행 모델은 [[생산자-소비자]], [[읽기-쓰기]], [[식사하는 철학자들]] 등이 있다. 이러한 실행 모델을 이해하고 문제를 해결할 수 있는 방법을 숙지해두는 것이 좋다

위 실행 모델을 이해하기 위한 필수 용어들은 다음과 같다
- 한정된 자원
	- 다중 스레드 환경에서 사용하는 자원, 크기나 숫자가 제한적이다
	- 데이터베이스 커넥션, 읽기/쓰기 버퍼
- 상호 배제
	- 한 번에 한 스레드만 공유 자원을 사용할 수 있는 경우
- 기아
	- 하나 이상의 스레드가 오랫동안(영원히) 자원을 기다리는 경우
- [[데드락]]
	- 여러 스레드가 다른 스레드의 작업이 끝나기를 기다리는 경우
- [[라이브락]]
	- 락을 거는 단계에서 각 스레드가 서로를 방해하는 경우

#### 동기화하는 메서드 사이의 의존성 이해
동기화하는 메서드 사이에 의존성이 존재한다면 동시성 코드에 찾아내기 어려운 버그가 생긴다. 따라서 **공유 객체 하나에는 메서드 하나만 존재하는것이 좋다**.

불가피하게 공유 객체 하나에 여러 메서드가 필요한 경우에는 다음 세 가지 방법을 고려한다.
- **클라이언트에서 잠금**
	- 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠근다
	- 마지막 메서드를 호출할 떄까지 잠금을 유지한다
- **서버에서 잠금**
	- "서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제" 하는 메서드를 서버에 구현한다
- **연결(Adapted) 서버**
	- 잠금을 수행하는 중간 단계를 생성한다
	- '서버에서 잠금'과 유사하지만 원래 서버는 변경하지 않는다

#### 올바른 종료 코드 구현
영구적으로 돌아가는 시스템을 구현하는 방법과 잠시 돌다 깔끔하게 종료되는 시스템의 구현 방법은 다르다. 올바르게 종료되는 코드를 구현하는 것은 어렵다. 충분히 시간을 투자하고, 이미 잘 만들어진 알고리즘을 도입하라

#### 스레드 코드 테스트
코드가 올바르다고 증명하는 것은 거의 불가능하다. 하지만 충분한 테스트를 한다면 위험도를 낮출 수 있다. 싱글 스레드에서 돌아가는 코드를 테스트 하는 것보다 다중 스레드에서 돌아가는 코드를 테스트하는 것이 훨씬 어렵다. 고려해야할 상황을이 급격하게 많아진다. 

최소한 다음 지침을 따르도록 하고, 테스트 방법은 찾아서 적용해보자.
- 문제를 노출하는 테스트 케이스를 작성하라
- 프로그램 설정, 시스템 설정 그리고 부하를 바꿔가며 자주 돌려라
- 테스트가 실패하면 원인을 추적하라
- 다시 돌렸더니 통과하더라는 이유로 그냥 넘어가면 안된다
