본 글은 '클린 코드(로버트.C.마틴)'를 정리한 글입니다.

---

코드의 표현력과 코드로 이루어진 함수를 깨끗하기 유지하는 것과 함께, 더 높은 차원의 클래스도 깨끗하게 유지해야한다

### 클래스 체계
클래스의 체계는 일반적으로 아래 순서를 따른다
- 정적 공개 상수
- 정적 비공개 변수
- 비공개 인스턴스 변수(공개 인스턴스 변수는 거의 없다)
- 생성자
- 함수
	- 공개 함수
	- 비공개 함수

공개 인스턴스 변수가 없는 이유는 [[캡슐화]]를 지키기 위함이다. 캡슐화는 객체의 외부에서 내부 속성을 변경하지 않도록 막고, 객체가 제공하는 공개 함수로만 객체의 상태를 변경할 수 있도록 한다.

가끔씩 비공개 함수를 protected 수준으로 열어 두는 경우도 있다. 하지만 캡슐화를 포기하는 방안은 최후로 미루어야 할 것이다.

### 클래스는 작아야 한다
클래스는 충분히 작아야 한다. 작은 클래스가 테스트하기 쉽고, 변경하기 쉽다.

함수는 물리적인 행의 수로 크기를 측정 했지만, 클래스는 책임의 수로 크기를 결정한다. 만약 클래스 이름이 모호 하다면 클래스의 책임이 많은 것이다. 예를들어, Processor, Manager, Super 등과 같이 모호한 단어가 있다면 클래스에 여러 책임이 존재한다는 것이다.

#### 단일 책임 원칙
[[SRP]](단일 책임 원칙)은 클래스의 변경 이유가 단 하나뿐이어야 한다는 원칙이다. 

```Java
public class SuperDashboard extends JFrame implements MetaDataUser {
	public Component getLastFocusedComponent();
	public void setLastFocused(Component lastFocused);
	public int getMajorVersionNumber();
	public int getMinorVersionNumber();
	public int getBuildNumber();
}
```

`SuperDashboard`는 충분히 작은 클래스인 것 처럼 보이지만 사실 그렇지 않다. 변경 해야할 이유가 두 가지기 때문이다. 첫 번째, `SuperDashboard`가 소프트웨어 버전 정보를 추적한다. 둘째, `SuperDashboard`는 자바 스윙 컴포넌트를 관리한다. 소프트웨어 버전 정보와 스윙 코드는 변경 시점이 다르다.

따라서, 버전 정보를 추적하는 클래스를 따로 분리할 수 있다

```Java
public class Version {
	public int getMajorVersionNumber();
	public int getMinorVersionNumber();
	public int getBuildNumber();
}
```

만능 클래스 하나 보다는 작은 여러 클래스로 이뤄진 시스템이 훨씬 관리하기 좋다.

#### 응집도
응집도가 높다는 말은 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인다는 의미다. 클래스의 인스턴스 변수가 적고, 모든 메서드에서 모든 인스턴스 변수를 사용하면 응집도가 매우 높다고 볼 수 있다. 특정 인스턴스 변수가 특정 메서드에서만 사용된다면 클래스를 분리해야 할 힌트다.

레거시 시스템에 큰 함수가 있다면, 일단 함수를 작게 나누어보자. 만약 함수를 작게 나눈 후 특정 인스턴스 변수가 특정 메서드에서만 사용된다면 클래스로 분리해보자.


### 변경하기 쉬운 클래스
거의 모든 시스템은 지속적으로 변화한다. 깨끗한 시스템은 클래스를 체계적으로 정리해 변경에 수반하는 위험을 낮춘다. SRP 원칙을 준수하여 클래스를 작게 유지하면 클래스의 변경이 쉬워진다.
#### 변경 사항의 격리
요구사항은 변화하기 마련이다. 인터페이스와 추상 클래스를 사용해 요구사항을 추상화 하고, 실제 요구사항은 구체 클래스에 작성하면 변경으로 인한 영향을 격리할 수 있다.

변경의 격리를 위해 인터페이스와 추상 클래스에 의존하다보면 클래스간 결합도가 느슨해지는데, 자연스레 [[DIP]](의존 역전 원칙)가 도출된다. DIP는 구체가 아닌 추상에 의존해야 한다는 원칙이다.