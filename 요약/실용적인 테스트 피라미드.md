---
URL: https://www.integer.blog/practical-test-pyramid
tags:
  - test
---
1. 수동적이고 반복적인 작업에 시간을 허비하지 않기 위해서는 빌드, 테스트, 배포 및 인프라에 대한 모든 것을 자동화하는 것이 좋다
2. 테스트 피라미드는 `(상) UI test - Service Tests - Unit Test (하)`로 이루어져 있다
3. **단위 테스트**는 특정한 단위가 제대로 동작하는 지 확인하기 위한 테스트다. 단위란 단일 메서드부터 단일 클래스가 될 수 있다
4. 단위 테스트에서는 **클래스의 공용 인터페이스**를 테스트 해야 한다. 비공개 메서드는 테스트하지 마라
5. 단위 테스트에서는 **관찰 가능한 동작**을 테스트한다. `x, y를 입력 받아 A 클래스를 호출한 결과를 가지고 B 클래스를 호출한 결과를 반환한다`를 테스트하라
6. **통합 테스트**는 어플리케이션의 외부에 있는 모든 부분과 어플리케이션의 통합을 테스트한다. 통합 테스트는 내부 구조와 동작을 테스트하는 화이트 박스 테스트가 될 수 있다
7. **계약 테스트**는 공급자-소비자간의 인터페이스(계약)를 테스트한다. 코드의 변경이 아닌 인터페이스의 변경이므로, 하루에 한 번 정도만 실행해도 좋다
8. **소비자 주도 계약 테스트(CDC)** 는 소비자가 계약의 구현을 주도하는 것이다. 소비자가 인터페이스에서 필요한 데이터를 확인하는 테스트를 작성한다.
9. **공급자 테스트** 는 공급자가 구현해야 하는 테스트이다. 공개 API는 모든 소비자를 고려할 수 없으므로, 안정적인 시스템을 유지하기 위해 공급자 테스트를 작성한다
10. **UI 테스트**는 사용자 인터페이스가 제대로 동작하는 지 테스트한다. 
11. 어플리케이션을 End-To-End 테스트한다는 것은 사용자 인터페이스를 통해 테스트한다는 것이지만, 그 반대는 아니다. UI 테스트가 반드시 백엔드를 포함해야 하는 것은 아니다. 
12. **사용자 인터페이스 End-To-End 테스트**는 사용자가 직접 경험하는 인터페이스를 통해 테스트하는 것이다. Selenium과 WebDriver 프로토콜을 사용할 수 있다
13. **REST API End-To-End 테스트**는 GUI를 통한 테스트보다 덜 복잡하면서 어플리케이션의 광범위한 부분을 테스트할 수 있다
14. **인수 테스트**는 어플리케이션을 블랙박스로 간주하고 기능이 제대로 동작하는지 테스트한다. 기술적인 관점뿐 아니라 사용작 관점에서 테스트한다.
15. **탐색 테스트**는 테서터의 자유와 창의성을 강조하여 실행 중인 시스템에서 품질 문제를 발견하는 수동 테스트이다. 탐색 테스트의 결과를 반영하여 자동화 할 수 있다.
16. 테스트 코드는 프로덕션 코드와 마찬가지로 단순성을 추구하고 중복을 피하기 위해 노력해야 한다. 
17. 상위 수준 테스트에서 오류를 발견했지만 하위 수준 테스트가 없는 경우 하위 수준 테스트를 작성해야 한다.
18. 테스트를 테스트 피라미드에서 가능한 한 아래로 밀어넣어라
19. 깔끔한 테스트 코드를 작성하라
	1. 프로덕션 코드와 동일한 수준의 주의와 관심을 기울여라
	2. 테스트당 하나의 조건을 테스트하라
	3. 테스트를 체계적으로 유지하기 좋은 니모닉(mnemonics)를 사용하라
	4. 가독성이 중요하다. 지나치게 건조하기 만들지 마라. 가독성을 향상시킨다면 중복도 괜찮다
	5. 확실하지 않은 경우 [The Rule of Three](https://blog.codinghorror.com/rule-of-three/?ref=integer.blog)를 사용하여 리팩토링 시기를 결정하라